# 概括

## TCP/IP的五层模型分别是什么?请从底层向上层说出来，各自的功能是什么？
- 第一层：物理层：底层数据传输。如网线，网卡标准。 

- 第二层：数据链路层：在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。如网卡MAC地址。

- 第三层：网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。

- 第四层：传输层：负责向两台主机进程之间的通信提供端到端的数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。

- 第五层：应用层：为应用程序提供交互服务。应用层协议主要有DNS、HTTP协议、FTP协议等。


## OSI七层模型与TCP/IP的四层模型及五层模型的对应关系是什么？

<table>
	<tr>
	    <th>OSI七层模型</th>
	    <th>TCP/IP四层模型</th>
	    <th>TCP/IP五层模型</th>  
	</tr >
	<tr >
	    <td>应用层</td>
	    <td rowspan="3">应用层</td>
	    <td rowspan="3">应用层</td>
	</tr>
	<tr>
	    <td>表示层</td>
	</tr>
	<tr>
	    <td>会话层</td>
	</tr>
	<tr>
	    <td>传输层</td>
	    <td>传输层</td>
       <td>传输层</td>
	</tr>
	<tr>
       <td>网络层</td>
	    <td>网络层</td>
       <td>网络层</td>
	</tr>
	<tr>
	    <td>数据链路层</td>
	    <td rowspan="2">网络接口层</td>
       <td>数据链路层</td>
	</tr>
	<tr>
	    <td>物理层</td>
	    <td>物理层</td>
	</tr>
</table>


## 请由下往上说出OSI七层模型、TCP/IP五层模型以及各层代表协议
<table>
	<tr>
	    <th>OSI七层模型</th>
	    <th>TCP/IP五层模型</th>
	    <th>代表协议</th>  
	</tr >
	<tr >
	    <td>应用层</td>
	    <td rowspan="3">应用层</td>
	    <td rowspan="3">HTTP(超文本传输协议)<br>DNS(域名系统)<br>DHCP(动态主机配置协议)<br>FTP(文件传输协议)<br>Telnet(远程登录协议)<br>SSH(安全外壳协议，用于远程登录)<br>SMTP(电子邮件协议)</td>
	</tr>
	<tr>
	    <td>表示层</td>
	</tr>
	<tr>
	    <td>会话层</td>
	</tr>
	<tr>
	    <td>传输层</td>
	    <td>传输层</td>
       <td>TCP(传输控制协议)<br>UDP(用户数据报协议)</td>
	</tr>
	<tr>
       <td>网络层</td>
	    <td>网络层</td>
       <td>IP(网际协议)<br>ICMP(Internet控制报文协议)<br>ARP(地址解析协议)<br>RARP(反向地址解析协议)<br>BGP(边界网关协议)<br>RIP(路由信息协议)</td>
	</tr>
	<tr>
	    <td>数据链路层</td>
	    <td rowspan="2">网络接口层</td>
       <td >PPP</td>
	</tr>
	<tr>
	    <td>物理层</td>
       <td>IEEE 802.1A</td>
	</tr>
</table>

## 在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？

1. **浏览器解析URL**。浏览器通过解析URL，得到URL中的参数，将域名(目标服务器名称)和需要请求的资源分离开，从而了解到需要请求的是哪个服务器，请求的是服务器上的什么资源。  
![在这里插入图片描述](https://img-blog.csdnimg.cn/1fcb10c33c834739ad7add3e86a38f0f.png)
1. **浏览器封装HTTP请求报文**。浏览器将解析URL得到的消息，封装成一个HTTP请求报文  
![在这里插入图片描述](https://img-blog.csdnimg.cn/cd889dea0d6e439ca340c8720ce7974e.png)
3. **DNS域名解析获取IP地址**。将解析URL得到的目标服务器名称通过DNS进行解析，得到目标服务器的IP地址。
![在这里插入图片描述](https://img-blog.csdnimg.cn/f4f6041bd414467f8a434a43da7580a2.png)
4. **建立TCP连接**。到这一步时，已经获取到了目标服务器的IP地址，就可以开始发送封装好了的HTTP请求报文了。既然要发送请求，就需要TCP协议通过三次握手为浏览器和服务器之间建立可靠的连接。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2da91637da17466799236cf06fe37234.png)
5. **浏览器通过TCP建立的连接，发送HTTP请求报文至网络层**。TCP三次握手完成后，浏览器与目标服务器之间就建立了一个可靠的通道，这时浏览器就可以发送自己的HTTP请求了。TCP在执行连接、收发数据、断开等各阶段操作时，都是通过IP协议进行传输的，IP协议将这些阶段的数据添加IP首部封装成IP数据报再进行传输。首先传送至网络层。
6. **网络层利用ARP协议，根据IP地址获取目标服务器的MAC地址，将报文发送给链路层，服务端将在链路层收到数据**。
7. **服务器响应请求**。服务端在链路层收到数据后，往上层发送，一直到应用层接收到浏览器发送来的HTTP请求报文，接着处理该HTTP请求报文并返回HTTP响应报文。
8. **浏览器根据响应报文内容显示界面**。浏览器接收到服务器返回的HTTP响应报文后，解析渲染并显示界面。


>参考：[经典面试题：在浏览器地址栏输入一个 URL 后回车，背后发生了什么](https://cloud.tencent.com/developer/article/1793846)


# 物理层

# 数据链路层

# 网络层

# 传输层

## TCP有那些特点？

## TCP三次握手的过程是什么？

## TCP为什么需要三次握手？两次握手可以吗？

## TCP四次挥手的过程是什么？

## TCP为什么需要四次挥手？

## 第四次挥手为什么要等待2MSL？

## TCP怎么保证可靠传输？(校验和、序列号、确认应答机制、重传机制、滑动窗口、流量控制、拥塞控制)

## 滑动窗口机制可以讲一下吗？
## TCP和UDP的区别是什么？

## TCP和UDP的使用场景可以列举一下吗？



# 应用层

## 应用层有哪些常见协议？其端口号及应用的传输层协议是什么？
|应用| 应用层协议 | 端口号 | 传输层协议 | 备注 |
| :---: | :--: | :--: | :--: | :--: |
| 域名解析 | DNS | 53 | UDP/TCP | 长度超过 512 字节时使用 TCP |
| 超文本传送协议 | HTTP | 80 | TCP | |
| 安全超文本传送协议 | HTTPS | 443 | - | HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密。也就是说HTTPS是基于应用层的|
| 安全外壳协议 | SSH | 22 | TCP | 可以通过加密和认证机制实现安全的访问和文件传输等业务| 
| 动态主机配置协议 | DHCP | 67/68 | UDP | |
| 文件传送协议 | FTP | 20/21 | TCP | 控制连接 21，数据连接 20 |
| 远程终端协议 | TELNET | 23 | TCP | |
| 简单邮件传送协议 | SMTP | 25 | TCP | |
| 邮件读取协议 | POP3 | 110 | TCP | |
| 网际报文存取协议 | IMAP | 143 | TCP | |
| 简单网络管理协议 | SNMP | 161/162 | UDP | |


## 什么是DNS？ 
DNS即Domain Name System，域名服务，可以将网址的域名和IP地址相互映射。DNS可以使人更方便地访问互联网，而不用去记住IP地址。  
将域名映射成 IP 地址称为正向解析，将 IP 地址映射成域名称为反向解析。  
## 为什么要使用DNS？
网址可以通过IP地址进行访问，但IP地址不方便记忆，因此人们设计出了域名，并通过DNS来将域名和IP地址相互映射。 

## 可以说一下域名的结构吗？
域名的结构为：**根域名**、**顶级域名**（top level domain，TLD）、**二级域名**、三级域名  
![](https://img-blog.csdnimg.cn/img_convert/23964173223da98006d980d15a4ff6ff.png)
## 你知道哪些DNS服务器？
根域名服务器，顶级域名服务器，权限域名服务器，本地域名服务器。    
- 根域名服务器：根域名服务器**保存所有的顶级域名服务器的地址**
- 顶级域名服务器：顶级域名服务器用来**管理注册在该顶级域名下的所有二级域名**的，**记录这些二级域名的 IP 地址**。
- 权限域名服务器：权限域名服务器是用来管理注册在二级域名下的所有三/四级域名的IP的地址。
- 本地域名服务器：本地域名服务器是电脑解析时的**默认**域名服务器，即电脑中设置的首选 DNS 服务器和备选 DNS 服务器。常见的有电信、联通等的本地 DNS 服务。  
当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给该主机的本地域名服务器。本地域名服务器管理本地域名的解析和映射，并且能够向上级域名服务器(根域名服务器、顶级域名服务器、权限域名服务器)进行查询。



## DNS查询方式有哪些？
递归查询和迭代查询。  
- 递归查询是指，如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案。    
  - 主机和本地域名服务器之间的查询属于递归查询，也就是说主机请求本地域名服务器，那么本地域名服务器作为请求的接收者一定要给主机想要的答案。  
- 迭代查询是指，如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求。  
  - 域名服务器之间的查询使用迭代查询方式，以免根域名服务器的压力过大。

## 本地域名缓存了解吗？请简单说一下
在浏览器进行网址访问的时候，为了减小本地域名服务器的压力，会优先查询本地域名缓存，如果未命中，再查询本地域名服务器。  
本地域名缓存有两种方式：浏览器缓存和操作系统缓存。
- **浏览器缓存**：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的 DNS 缓存时间，如 Chrome 的过期时间是 1 分钟，在这个期限内不会重新请求 DNS 
- **操作系统缓存**：操作系统的缓存其实是用户自己配置的 hosts 文件。比如 Windows10 下的 hosts 文件存放在 C:\Windows\System32\drivers\etc\hosts


## DNS的解析过程(域名解析为IP地址)能说一下吗？
一段话：  
在浏览器中进行网址访问的时候，会优先查询浏览器缓存，如果未命中则继续查询操作系统缓存，若没有命中，再查询本地域名服务器，然后本地域名服务器会递归的查找域名记录，首先查找自己的DNS缓存，若没有命中，向根域名服务器、顶级域名服务器、权限域名服务器进行迭代查找。最终本地域名服务器得到域名对应的IP地址，将IP地址返回给浏览器。


详细过程：
1. 首先搜索「浏览器的 DNS 缓存」，缓存中维护一张域名与 IP 地址的对应表；
2. 若没有命中，则继续搜索「操作系统的 DNS 缓存」；
3. 若仍然没有命中，则操作系统将域名发送至「本地域名服务器」，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是「递归查询」）；
4. 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行「迭代查询」（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：
   - 首先本地域名服务器向「根域名服务器」发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案
   - 本地域名服务器拿到这个「顶级域名服务器」的地址后，就向其发起请求，获取「权限域名服务器」的地址
   - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
5. 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来
6. 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来
7. 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来  

![在这里插入图片描述](https://img-blog.csdnimg.cn/ec15a8b26cd849c4a87198cb400c89fc.png)

>参考：[超详细 DNS 协议解析](https://github.com/Veal98/cs-wiki/blob/master/vuepress-doc/docs/10-10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/30.%E5%BA%94%E7%94%A8%E5%B1%82/10.%E8%B6%85%E8%AF%A6%E7%BB%86%20DNS%20%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90.md)



## DNS协议基于TCP还是UDP？
DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。  
大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。  
如果返回的响应超过512 字节，DNS会使用TCP进行传输，因为UDP 最大只支持 512 字节的数据。

## 什么是HTTP？
HTTP（HyperText Transfer Protocol），即超文本传输协议，所有的 WWW（万维网） 文件都必须遵守这个标准。HTTP 是用于客户端和服务器端之间的通信的协议。

## HTTP有哪些版本？它们之间的区别是什么？
HTTP版本|	功能|	特点
--|--|--
HTTP/0.9（1991）|1. 仅支持GET请求方式<br>2. 客户端仅能访问HTML格式的资源|那时的HTTP并没有作为正式标准被建立，因此被称为HTTP0.9
HTTP/1.0（1996）	|1. 新增支持HEAD、POST请求方式<br>2. 增加了响应状态码，标记可能的错误原因<br>3. 引入了协议版本号概念<br>4. 传输文本不再局限于HTML格式，根据Content-Type可以支持多种数据格式|工作方式是短连接
HTTP/1.1（1997）|1. 新增支持PUT、DELETE等新的请求方式<br>2. 增加了长连接功能，支持持久连接<br>3. 加入了管道机制（浏览器默认不开启）<br>4. 强制加入HOST请求头<br>5. 支持断点续传|是目前互联网上使用最广泛的协议，功能也非常完善
HTTP/2.0（2015）	|1. 废弃管道机制，使用多路复用机制（数据流进行串行传输）<br>2. 采用二进制分帧，不再是纯文本<br>3. 支持首部压缩（HPATCH）<br>4. 支持服务器推送<br>5. 增强了安全性，“事实上”要求加密通信|一个HOST只建立一个TCP连接，解决了HTTP线头阻塞，但依然存在TCP线头阻塞问题
## 你知道URI和URL的区别吗？
 URI是Uniform Resource Identifier ，**统一资源标识符**，URL是Uniform Resource Location，**统一资源定位符**。URI 用字符串标识某一处互联网资源，而 URL 标识资源的地点（互联网上所处的位置），URL 是 URI 的子集。

## 你知道HTTP的请求报文格式吗？
HTTP 请求报文由 3 大部分组成：
- 请求行：包括请求方法，访问资源的URL，使用的HTTP版本。位置在 HTTP 请求报文的第一行。
- 请求头：格式为"属性名: 属性值"，服务端将根据请求头获取客户端的信息，一般包括Host、Connection等。位置从第二行开始，到第一个空行结束。请求头和请求体之间存在一个空行
- 请求体：用户的请求数据，如用户名，密码等，通常以键值对的方式传递数据。位置在请求报文的最后一行。

举个请求报文的例子：

![](https://img-blog.csdnimg.cn/img_convert/528d908fac6fa8b5c2add33c34b12b3a.png)

请求行开头的 `POST` 表示请求访问服务器的类型，称为方法（method）。随后的字符串 `/form/login` 指明了请求访问的资源对象。最后的 `HTTP/1.1` 即 HTTP 的版本号，用来提示客户端使用的 HTTP  协议功能。

综上来看，这段请求的意思就是：请求访问某台 HTTP 服务器上的 `/form/login` 页面资源，并附带参数 name = veal、age = 37。


## HTTP请求报文中的请求方法有什么作用？你知道哪些请求方法？
请求行中的请求方法的作用是：可以指定请求的资源按照期望产生某种行为，即**使用方法给服务器下命令**。

在HTTP/1.1中，包括`GET`、`POST`、`PUT`、`HEAD`、`DELETE`、`OPTIONS`。比较常见的是`GET`、`POST`、`PUT`请求。

- GET方法用来请求访问资源，指定的资源经服务器端解析后返回响应内容。
![](https://img-blog.csdnimg.cn/img_convert/7fa66ca820228880506ed8257fdefaff.png)
- POST方法用来向指定资源提交数据，进行处理请求数据被包含在请求体中。
![](https://img-blog.csdnimg.cn/img_convert/023c238bcf5e93e30e827b3a63c96539.png)
- PUT方法用来传输文件，由于自身**不带验证机制，任何人都可以上传文件**，因此存在安全性问题，一般不使用该方法。
![](https://img-blog.csdnimg.cn/img_convert/3a25e512fbec622f0e3bd7fe691691cc.png)
- HEAD方法类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头，确认URI的有效性以及资源更新的日期时间等。
![](https://img-blog.csdnimg.cn/img_convert/61558ebc134ed0e68f7ec263caa86ad9.png)
- DELETE方法用来删除文件，不带验证机制，请求服务器删除指定的资源。
![](https://img-blog.csdnimg.cn/img_convert/4e47ec0a306d04324d1d4c220b885068.png)
- OPTIONS方法用于**获取当前 URI 所支持的方法**。若请求成功，会在 HTTP 响应头中包含一个名为 “`Allow`” 的字段，值是所支持的方法，如 “GET, POST”。
![](https://img-blog.csdnimg.cn/img_convert/49c3ffe2448bbede5c1b0719df026e93.png)


## GET和POST的区别是什么？
- GET是获取数据，post是修改数据
- GET把请求的数据放在URL上，所以GET不太安全。而POST把数据放在HTTP请求报文的请求体内，相对安全。
- GET提交的数据大小有限制， 限制取决于浏览器， POST理论上没有限制。
- GET请求会被浏览器主动缓存，而POST不会，除非手动设置。
- GET是幂等性的，而POST不是幂等性的
>幂等性：对同一URL的多个GET请求应该返回同样的结果。例如：用户在APP上连续点击了多次提交订单，后台应该只产生一个订单；向购物APP发起支付请求，由于网络问题或系统BUG重发，购物APP应该只扣一次钱。

## POST请求是绝对安全的吗？
不是绝对安全的。  
虽然POST请求将数据放在HTTP请求报文的请求体内，地址栏上见不到请求数据。但因为HTTP在网络上是明文传输的，只要通过抓包的手段，就能完整获取HTTP请求报文，进而得到POST请求发送的数据。  
要想安全传输，可以使用HTTPS协议。

## HTTP的请求头有什么作用？说出几种常见的HTTP请求头？
请求头用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。常见的请求头有：  
- **Host**：告知服务器请求的资源所处的互联网主机名和端口号。该字段是 HTTP/1.1 规范中唯一一个必须被	包含在请求头中的字段。
- **Connection**：表示客户端与服务连接类型；Keep-Alive 表示持久连接，close 已关闭
- **Content-Length**：请求体的长度
- **Cookie**：客户端的 Cookie 就是通过这个报文头属性传给服务端的。
- **Accept**：告诉服务端，该请求所能支持的响应数据类型。（对应的，HTTP 响应报文中也有这样一个类似的字段 `Content-Type`，用于表示服务端发送的数据类型，如果 `Accept` 指定的类型和服务端返回的类型不一致，就会报错）
- **Accept-Language**：浏览器通知服务器，浏览器支持的语言
- **Range**：对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围
- **Referer**：表示这个请求是从哪个 URI 跳过来的。比如说通过百度来搜索淘宝网，那么在进入淘宝网的请求报文中，Referer 的值就是：www.baidu.com。如果是直接访问就不会有这个头。这个字段通常用于防盗链。

## 你知道HTTP的响应报文格式吗？
HTTP的响应报文由三部分组成：
- 响应行: 包括使用的HTTP协议版本，响应状态码，状态描述，位置在HTTP响应报文的第一行。
- 响应头: 格式为"属性名: 属性值"，响应头字段一般包括Connection、Content-Type等。位置从第二行开始，到第一个空行结束。响应头和响应体之间存在一个空行。
- 响应体: 服务器返回给客户端的内容。

举个响应报文的例子：
![](https://img-blog.csdnimg.cn/img_convert/ac9f0a5533fa31f07403634808d87424.png)
## 你知道哪些常见的HTTP状态码？
状态码由 3 位数字组成，第一个数字定义了响应的类别：  
| |类别	|原因短语|
--|--|--
1XX	|Informational（信息性状态码）|	接受的请求正在处理
2XX	|Success（成功状态码）|	请求正常处理完毕
3XX	|Redirection（重定向状态码）|	需要进行附加操作以完成请求
4XX	|Client Error（客户端错误状态码）|	服务器无法处理请求
5XX	|Server Error（服务器错误状态码）|	服务器处理请求出错

状态码 | 状态码英文名称描述 | 中文描述
--|--|--
200|OK|	客户端请求成功。一般用于GET与POST请求
204|No Content|	无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。
206|Partial Content|服务器已经完成了部分 GET 请求（客户端进行了范围请求）。响应报文中包含 Content-Range 指定范围的实体内容
301|Moved Permanently|永久重定向。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
302|Found|临时重定向。请求的资源临时被移动。客户端应继续使用原有URI。换句话说，已移动的资源对应的URI将来还有可能发生改变。
303|See Other|	临时重定向，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问
304|Not Modified|表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。返回304时，不包含任何响应主体。<br>(注：虽然304被划分在3XX，但和重定向没有关系)
307|Temporary Redirect|	临时重定向，和302有着相同含义。POST不会变成GET
400|Bad Request|客户端请求有语法错误，服务器无法理解。
401|Unauthorized|请求未经授权。该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。
403|Forbidden|不允许访问资源。服务器理解请求客户端的请求，但是拒绝执行此请求
404|Not Found|请求资源不存在。可能是路径错误等原因造成的。
408	|Request Time-out|	服务器等待客户端发送的请求时间过长，超时
500|Internal Server Error|	服务器内部错误，无法完成请求。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。
503|Service Unavailable|服务器当前处于超负载或正在停机维护，暂时不能处理客户端的请求，一段时间后可能恢复正常

## HTTP的响应头有什么作用？说出几种常见的HTTP响应头？
响应头用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等。常见的响应头有：  
 - Allow：服务器支持哪些请求方法。
 - Content-Encoding：文档的编码方法
 - Content-Length：文档内容长度
 - Content-Type：文档属于什么类型
 - Data：当前时间
 - Expires：文档的过期时间，过期后不再缓存该文档
 - Location：将客户端引导至新的URL去访问文档，通常与HTTP状态码302(临时重定向)配合使用。
 - Set-Cookie：用于从服务器向用户发送Cookie，然后浏览器会将数据设置给下次请求的Cookie请求头，返回服务器。

## 什么是HTTP的短连接？
短连接也被称为非持久连接。工作方式是：客户端和服务器每进行一次 HTTP 会话，就建立一次连接，任务结束就中断连接。由于 HTTP 是基于TCP协议的，所以连接的每一次建立或者断开都需要 TCP 三次握手或者 TCP 四次挥手的开销。
>举例：当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如JavaScript 文件、图像文件、CSS文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。

这种方式存在巨大的弊端。比如访问一个包含多张图片的 HTML 页面，每请求一张图片资源就会造成无谓的 TCP 连接的建立和断开，大大增加了通信量的开销

HTTP/1.0中默认使用短连接。

## 什么是HTTP的长连接？
长连接也被称为持久连接。工作方式是：当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。使用长连接的 HTTP 协议，会在请求头加入这行代码：`Connection:keep-alive`。
>Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

从 HTTP/1.1 起，默认使用长连接。

HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。

## 讲一下HTTP的管道机制？
默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。  
管道机制也被称为流水线机制。是HTTP/1.1引入的机制。管道机制的实现基于HTTP的持久连接机制。通过管道机制可以实现：在同一条持久连接上连续发出请求，而不用等待响应返回后再发送，这样就可以做到同时并行发送多个请求，而不需要一个接一个地等待响应。  
![](https://img-blog.csdnimg.cn/img_convert/b9cc4fe28bbe86efa5c97f367a997bed.png)



## HTTP的无状态的还是有状态的？
HTTP 协议是无状态协议。也就是说他不对之前发生过的请求和响应的状态进行管理，即无法根据之前的状态进行本次的请求处理。
- 优点：由于不必保存状态，减少了服务器的 CPU 及内存资源的消耗，也因此被广泛应用。	
- 缺点：HTTP无法记住用户的状态，每次页面的跳转都会导致用户需要再次重新登录。但可以通过引入Cookie来解决无状态导致的问题。

## 什么是Cookie？为什么要引入Cookie？
HTTP协议是无状态的协议，无法记住用户的状态，为了跟踪用户的整个会话，需要引入某种机制来识别具体的用户身份。Cookie就是这样的一种机制。 

Cookie是浏览器保存在用户电脑上的一小段文本，通俗的来讲就是当一个用户通过HTTP访问到服务器时，服务器会将一些 Key/Value键值对返回给客户端浏览器，并给这些数据加上一些限制条件，在条件符合时这个用户下次访问这个服务器时，数据通过请求头又被完整地给带回服务器，服务器根据这些信息来判断不同的用户。
>Cookie是有大小，数量限制的   

## 通过Cookie实现用户状态跟踪的具体过程能说一下嘛？
Cookie 会根据从服务器端发送的响应报文中的一个叫作 `Set-Cookie` 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值发送出去。服务器端收到客户端发来的 Cookie 后，会去检查究竟是哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

形象来说，在客户端第一次请求后，服务器会下发一个装有客户信息的身份证，后续客户端请求服务器的时候，带上身份证，服务器就能认得了。

下图展示了发生 Cookie 交互的情景：

1）**没有 Cookie 信息状态下的请求**：

![](https://img-blog.csdnimg.cn/img_convert/e8aa1836dd46f569aad03ce81a216533.png)

对应的 HTTP 请求报文（没有 Cookie 信息的状态）

```
GET /reader/ HTTP/1.1
Host: baidu.com
* 首部字段没有 Cookie 的相关信息
```

对应的 HTTP 响应报文（服务端生成 Cookie 信息）

```
HTTP/1.1 200 OK
Date: Thu, 12 Jul 2020 15:12:20 GMT
Server: Apache
<Set-Cookie: sid=1342077140226; path=/; expires=Wed, 10-Oct-12 15:12:20 GMT>
Content-Type: text/plain; charset=UTF-8
```

2）**第 2 次以后的请求（存有 Cookie 信息状态）**

![](https://img-blog.csdnimg.cn/img_convert/a779642f57b238f57824ad48dc184ced.png)

对应的 HTTP 请求报文（自动发送保存着的 Cookie 信息）

```
GET /image/ HTTP/1.1
Host: baidu.com
Cookie: sid=1342077140226
```

## Cookie有哪些类别？
有会话级别Cookie和持久级别Cookie。
- 会话级别Cookie：所谓会话级别Cookie，就是在浏览器关闭之后Cookie就会失效。

- 持久级别Cookie：保存在硬盘的Cookie，只要设置了过期时间就是硬盘级别Cookie。
## 什么是Session？为什么要引入Session？
Cookie是有大小限制和数量限制的，若客户端需要保存的信息过多，Cookie将无法保存，并且客户端向服务端的传输量增加，也会带来额外的性能开销。为了解决这个问题，引入了Session。

Session是基于Cookie来工作的。当浏览器第一次访问服务器时，服务器创建Session并将SessionID通过Cookie带给浏览器保存在客户端，同时服务器根据业务逻辑保存相应的客户端信息保存在Session中；客户端再访问时上传Cookie，服务器得到Cookie后获取里面的SessionID，来维持状态。

## Session的具体工作流程能说一下吗？
首先浏览器请求服务器访问Web站点时，服务器首先会检查这个客户端请求是否已经包含了一个Session标识，称为SessionID，如果已经包含了一个SessionID则说明以前已经为此客户端创建过Session，服务器就按照SessionID把这个Session检索出来使用。

如果客户端请求不包含SessionID，则服务器为此客户端创建一个Session，并且生成一个与此Session相关联的独一无二的SessionID存放到Cookie中。这个SessionID将在本次响应中返回到客户端保存。

在后续的交互过程中，浏览器端每次请求时，都会带着这个SessionID，服务器根据这个SessionID就可以找得到对应的Session。以此来达到共享数据的目的。


## Cookie和Session的相同点和不同点是什么？
相同点：
- Session和Cookie都是客户端与服务器之间保持状态的解决方案。
- Session通过Cookie工作，Cookie传输的SessionID让Session知道这个客户端到底是谁。

不同点：
- 存储位置不同。Cookie 存储在客户端；Session 存储在服务端。
- 存储的数据大小不同。单个 Cookie 保存的数据受浏览器的限制，很多是不能超过4K的；对于 Session 来说存储受当前服务器的内存限制，但出于对服务器的性能考虑，Session 内不要存放过多的数据，并且需要设置 Session 删除机制。
- 存储的数据类型不同。两者虽然都是Key-Value的结构，但针对Value的类型是有差异的。Cookie的Value只能是字符串类型；Session的Value是Object类型，存储什么数据都可以。
- 有效期不同。Cookie 可设置为持久级别Cookie，比如我们经常使用的默认登录功能；Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。

## Cookie和Session应该如何选择？(Cookie和Session的应用场景是什么？)
- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session。
- Cookie 存储在客户端，容易被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。因此，Cookie通常用于保存不重要的用户信息，重要的信息使用Session保存。
## HTTP的优点和缺点是什么？
HTTP的优点有：
- 简单、灵活和易于扩展
- 拥有成熟的软硬件环境，应用非常广泛，是互联网的基础设施
- HTTP是无状态的，可以轻松实现集群化，扩展性能，可以利用Cookie技术实现有状态。

HTTP的缺点有：
- 通信使用明文（不加密），内容可能被**窃听**
- 不验证通信对方的身份，因此有可能遭遇**伪装**
- 无法证明报文的完整性，所以有可能被**篡改**

HTTP的缺点不仅在 HTTP 上出现，其他未加密的协议中也存在类似问题，为了解决 HTTP 的痛点，产生了HTTPS。

## 什么是HTTPS协议？HTTP和HTTPS有什么区别？
HTTP + 加密 + 认证 + 完整性保护就是 HTTPS 协议

## 什么是对称加密和非对称加密？




# 网络安全

## 什么是XSS攻击？

## 什么是CSRF攻击？