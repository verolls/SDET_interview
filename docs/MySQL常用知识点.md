# 数据库基础知识

## 什么是关系型数据库？

关系型数据库是指采用了关系模型来组织数据的数据库。

关系型数据库代表：Oracle, MySQL

优点：

- 容易理解，二维表的结构非常贴近现实世界，二维表格，容易理解。

- 使用方便，通用的SQL语句使得操作关系型数据库非常方便。

- 易于维护，数据库的ACID属性，大大降低了数据冗余和数据不一致的概率。

缺点：

- 读写性能差
- 难以扩展

## 什么是非关系型数据库？

非关系型数据库也叫NoSQL，采用键值对的形式进行存储，是一种非关系型的、分布式的，且一般不保证ACID的数据存储系统。

非关系型数据库代表：MongoDB, Redis

优点：

- 读写性能高，
- 易于扩展

缺点：

- 由于NoSQL约束少，所以不能像关系型数据库一样提供WHERE字段属性的查询。因此适合存储较为简单的数据。有一些不能够持久化数据，所以需要和关系型数据库结合。

## 关系型数据库和非关系型数据库的区别是什么？

- 关系型数据库:
  - 容易理解。因为它采用了关系模型来组织数据。
  - 可以保持数据的一致性。
  - 数据更新的开销比较小。
  - 支持复杂查询（带where子句的查询）


- 非关系型数据库:
  - 读写效率高。
  - 基于键值对，数据的扩展性很好。
  - 可以支持多种类型数据的存储，如图片，文档等等。

## 关系型数据库和非关系型数据库的应用场景是什么？

关系型数据库适合存储结构化数据，比如：用户的账号、地址：

- 这些数据通常需要做结构化查询，比如说join，这个时候，关系型数据库就要胜出一筹。

- 这些数据的规模、增长的速度通常是可以预期的。

- 关系型数据库具有一致性,适合存储比较复杂的数据。



NoSql适合存储非结构化数据，比如：文章、评论：

- 这些数据通常用于模糊处理，例如全文搜索、机器学习，适合存储较为简单的数据。

- 这些数据是海量的，并且增长的速度是难以预期的。

- 按照key获取数据效率很高，但是对于join或其他结构化查询的支持就比较差。

## 关系型数据库的三大范式可以讲一下吗？

### 第一范式（1NF): 

条件：

- 确保每列的原子性，即数据表里的字段都是不可分割的。

举例：

下面学生表的设计明显不满足要求，“年级专业”字段可以再分。

学号|姓名|年龄|年级专业
--|--|--|--
201511216776|王玉伟|20|15级软件工程

符合第一范式的做法为：

学号|姓名|年龄|年级|专业
--|--|--|--|--
201511216776|王玉伟|20|15级|软件工程


### 第二范式（2NF):

条件：

- 确保每列的原子性，即数据表里的字段都是不可分割的。
- 表中必须有主键。
- 其他非主键属性必须完全依赖主键（若是联合主键，不能依赖主键一部分）。

举例：

以学号为主键的时候，确保该学生别的字段都完全依赖学号，不能出现下面这种课程名不依赖学号而依赖课程号的设计。

学号|姓名|年龄|课程名|课程号
--|--|--|--|--
201511216776|王玉伟|20|英语|20003

符合第二范式的做法：

学号|姓名|年龄
--|--|--
201511216776|王玉伟|20

课程名|课程号
--|--
英语|20003

### 第三范式（3NF):

条件：

- 确保每列的原子性，即数据表里的字段都是不可分割的。
- 表中必须有主键。
- 其他非主键属性必须完全依赖主键（若是联合主键，不能依赖主键一部分）。
- 表中非主键字段完全直接依赖主键，不能是传递依赖


举例：

下表中，学院依赖于主键学号，但是学院地址依赖于学院，这样对主键就是不是直接依赖。

学号|姓名|年龄|年级|学院|学院地址
--|--|--|--|--|--
201511216776|王玉伟|20|15级|计算机学院内蒙古呼和浩特市赛罕区

符合第三范式的做法:(删除有间接依赖的字段)

学号|姓名|年龄|年级|学院
--|--|--|--|--
201511216776|王玉伟|20|15级|计算机学院

# MySQL 基础知识

## 什么是 SQL？

SQL(Structured Query Language)，中文是结构化查询语言。

SQL是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系型数据库系统。标准 SQL 可以在任何数据库中使用。

## 什么是 MySQL？

MySQL是数据库管理系统(DBMS, Database Management System)

## SQL 和 MySQL的关系是什么？

SQL 是结构化查询语言，MySQL是数据库管理系统，MySQL可以使用SQL来查询数据库。

## MySQL常用的数据类型有哪些？

- 整型

MySQL数据类型	|含义（有符号）
--|--
tinyint|	1个字节 范围(-128~127)
smallint|	2个字节 范围(-32768~32767)
mediumint|	3个字节 范围(-8388608~8388607)
int|	4个字节 范围(-2147483648~2147483647)

- 浮点型

MySQL数据类型|	含义
--|--
float(m,d)|	单精度浮点型 8位精度(4字节) m总个数，d小数位
double(m,d)|	双精度浮点型 16位精度(8字节) m总个数，d小数位

设一个字段定义为float(6,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。

- 字符串

MySQL数据类型|	含义
--|--
char(n)|	定长字符串，最多255个字符
varchar(n)|	变长字符串，最多65535个字符

- 日期时间

MySQL数据类型|	含义
--|--
date|	日期 '2008-12-2'
time|	时间 '12:25:36'
datetime|	日期时间 '2008-12-2 22:06:44'
timestamp|	自动存储记录修改时间

## MySQL中，一条SQL查询语句是怎么执行的？

![在这里插入图片描述](https://img-blog.csdnimg.cn/1859b006bc244544ade91353c3bbb09e.png)

1. 客户端发起查询请求，与连接器建立连接。
2. 连接器确定用户是否有查询权限，若没有权限，返回错误信息，若有权限，执行下一步。
3. 查询缓存：存在缓存则直接返回，不存在则执行下一步。
4. 分析器对SQL进行词法分析和语法分析操作，判断SQL语句是否有语法错误，如果没问题就执行下一步。 
5. 优化器对执行的SQL优化选择最优的执行方案方法 
6. 执行器先进行权限校验，看用户是否有执行权限，若没有权限则返回错误信息，若有权限，执行器就会调用数据库引擎提供的接口，返回引擎的执行结果。
7. 执行引擎，查询数据，并把结果集返回给客户端，如果开启查询缓存则会缓存查询结果。


## MySQL 中，查询语句关键字的执行顺序是什么？

```sql
FROM ： 对FROM左边的表和右边的表计算笛卡尔积，产生虚表VT1；
ON ： 对虚拟表VT1进行ON筛选，只有那些符合条件的行才会被记录在虚拟表VT2中；
JOIN ：如果是OUT JOIN，那么将保留表中（如左表或者右表）未匹配的行作为外部行添加到虚拟表VT2中，从而产生虚拟表VT3；
WHERE ：对虚拟表VT3进行WHERE条件过滤，只有符合的记录才会被放入到虚拟表VT4；
GROUP BY：根据GROUP BY子句中的列，对虚拟表VT4进行分组操作，产生虚拟表VT5；
WITH{CUBE|ROLLUP}：对虚拟表VT5进行CUBE或者ROLLUP操作，产生虚拟表VT6；
HAVING ：对虚拟表VT6进行 HAVING 条件过滤，只有符合的记录才会被插入到虚拟表VT7中；
SELECT ：执行SELECT操作，选择指定的列，插入到虚拟表VT8中；
DISTINCT ：对虚拟表VT8中的记录进行去重，产生虚拟表VT9；
ORDER BY ：将虚拟表VT9中的记录按照进行排序操作，产生虚拟表VT10；
LIMIT ：取出指定行的记录，产生虚拟表VT11，并将结果返回。

```

## GROUP BY 多个字段的时候，可以讲下分组原理吗？

首先按照第一个字段分组，如果第一个字段有相同值，则把分组结果再按第二个字段进行分组，以此类推。

如果第一个字段分组每个值都是唯一的，则不会再按照第二个字段进行分组了

## HAVING 可以代替 WHERE 吗？什么时候才会用 HAVING

不可以。HAVING 一般和 GROUP BY 一起使用。

GROUP BY 分组后，需要进行筛选数据时用 HAVING。

## HAVING 和 WHERE 有什么区别？

where|having
--|--
不可以使用聚合函数|可以使用聚合函数
分组前过滤|分组后过滤
查询条件中不可以使用字段别名|查询条件中可以使用字段别名
用于过滤数据行|用于过滤分组后的结果集 
根据数据表的字段直接过滤|根据已查询出的字段进行过滤

## MySQL 常用的有几种连接？它们有什么区别？

常用的有内连接、左连接、右连接、全连接。

(INNER JOIN)内连接：返回两个表共有的记录，没匹配的数据不显示

(LEFT JOIN)左连接：以左表为基准，获取左表的所有记录，右表中没匹配的数据填 null

(RIGHT JOIN)右连接：以右表为基准，获取右表的所有记录，左表中没匹配的数据填 null

(FULL JOIN)全连接：返回两个表的所有记录，没匹配的数据填 null
> MySQL不支持 FUll JOIN 这种写法，可以用UNION实现

![在这里插入图片描述](https://img-blog.csdnimg.cn/4f3f037175d443a1ba09f67b98cae9a4.png)

# MySQL 存储引擎


## MySQL默认的存储引擎是什么？

InnoDB


## MySQL常用的存储引擎有什么？它们之间的区别是什么？

InnoDB和MyISAM。

比较点|MyISAM|InnoDB
--|--|--
事务|不支持|支持
外键|不支持|支持
全文索引|支持|不支持，但可以通过插件支持，且效果更好
锁|只支持表锁|表锁、行锁
可移植性|数据以文件方式存储，移植性好|数据量大的时候移植性一般
主键|允许没有任何索引和主键的表存在|没有设置主键会自动生成一个主键

适用场景：

- MyISAM适合： 插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择。
- InnoDB适合： 可靠性要求比较高，或者要求事务； 表更新和插入都相当的频繁， 大量的INSERT或UPDATE


# MySQL 事务

## 什么是事务？事务的使用场景是什么？

事务是数据库并发控制的基本单位，可以看作一系列SQL语句的数据库操作集合，事务要么全部成功，要么全部失败。

MySQL 事务主要用于处理操作量大，复杂度高的数据。

- 比如说，在人员管理系统中删除一个人员时，既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这些数据库操作语句就构成一个事务。
- 再比如，银行转账需要两个过程来完成，首先需从某个账户扣除一定金额，之后在另个账户中增加相同的金额。如果这两个过程不同时，从第一个账户中扣除金额后没来得及增加第二个账户的金额就发生停电或者服务器崩溃，这将给用户和银行造成很大的损失。如果采用事务处理上述过程，即使出现上述事故也不会给用户带来损失。

## 事务的四个基本特性是什么？

ACID是事务的四个基本特性：

- 原子性(Atomicity): 又称为不可分割性。一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- 一致性(Consistency): 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
- 隔离性(Isolation): 又称为独立性。数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- 持久性(Durability): 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

## 数据库并发事务时，如果不对事务进行并发控制，会产生哪些异常？(你知道哪些并发控制异常？)

数据库并发会带来脏读、幻读、不可重复读这四个常见问题，其中：

**脏读**：事务之间不隔离，读到了其他事务还没有提交的数据，且其他事务进行了回滚，导致读到的数据无效。
>举例：T1 首先读取var变量为50，接着更新为100，但并未提交，T2 已经读取var为100，此时T1 做了回滚。最终 T2 读取的var和数据库的var不一样。

**幻读**：T1 根据条件查询得到了 N 条数据，但此时 T2 更改或者增加了 M 条符合 T1 查询条件的数据，这样当 T1 再次进行查询的时候发现会有 N+M 条数据，产生了幻读，主要是针对insert语句。

**不可重复读**：事务对某数据进行读取，发现两次读取的结果不同，也就是说没有读到相同的内容。这是因为有其他事务对这个数据同时进行了修改或删除。主要是针对update语句。
> 举例：T1 读取一个数据，T2 对该数据做了修改。如果 T1 再次读取这个数据，此时读取的结果和第一次读取的结果不同。  

## 幻读和不可重复读区别是什么？可以举个例子吗？

**幻读的重点在于新增，不可重复读的重点是修改。**

- 幻读（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，T1 读取了所有工资大于3000的人，共查到4条记录，这时 T2 又插入了一条工资大于3000的记录，T1 再次读取时查到的记录就变为了5条，这样就导致了幻读。
- 不可重复读（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：T1 中的A先生读取自己的工资为 1000 的操作还没完成，T2 中的B先生就修改了A的工资为2000，导致A先生再读自己的工资时工资变为 2000；这就是不可重复读。




## 如何解决事务并发产生的异常？(你知道哪些事务隔离级别？)

当数据库出现有多个事务同时执行时，就可能出现脏读，幻读，不可重复读等异常，为了解决这些异常，定义了四种事务隔离级别。

- 读未提交(RU, read uncommitted): 一个事务还未提交时，它做的变更就可以被别的事务看到。
>相当于事务不隔离，一般不会使用这种隔离级别

- 读已提交(RC, read committed): 事务提交以后，它做的变更才能被其它事务看到。但是在这个事务未提交之前，数据库中发生的变更，这个事务也能看见。
>不会出现脏读，会出现不可重复读和幻读，Oracle默认级别

- 可重复读(RR, repeatable read): 事务总是只能看见在启动的那个时刻，数据库的状态。事务未提交之前做的变更，其它事务看不见。事务执行期间，数据库中已经发生的变更，这个事务也看不见。只能看见事务刚启动时刻，数据库的状态。
>不会出现脏读和不可重复读，会出现幻读，MySQL默认级别

- 串行化(serializable): 事务对某一行的操作会加锁，“写”会加“写锁”，“读”会加“读锁”，在锁释放掉之前，其它的事务都无法都这一行的记录进行操作。必须等之前的事务执行完毕，释放锁。后面的事务又会重新加锁。事务完全串行化的执行，隔离级别最高，执行效率最低
>不会出现脏读、不可重复读、幻读，但并发性非常差，一般不会使用这种隔离级别

隔离级别越高，安全性越高，但性能越差。

### 四种隔离级别总结表

>“是”表示会出现这种问题，“否”表示不会出现这种问题

级别	|名字	|隔离级别	|脏读	|不可重复读	|幻读	
--|--|--|--|--|--
1	|读未提交	|read uncommitted|	是	|是	|是
2	|读已提交	|read committed	|否	|是	|是	
3	|可重复读|	repeatable read|	否	|否	|是	
4	|串行化	|serializable	|否	|否	|否|


# MySQL 索引

## 什么是索引？

帮助 Mysql 高效检索数据的数据结构

## 索引有哪些优点？

- 使用索引可以提高数据的检索速度
- 通过创建唯一索引，可以保证每一行数据的唯一性
- 可以加快表之间的连接
- 用来排序或分组的字段添加索引可以加快分组或排序

## 索引有哪些缺点？

- 创建索引和维护索引需要时间成本，成本随数据量增加而增大
- 创建索引和维护索引需要空间成本，每一条索引都要占据数据库的物理存储空间，数据量越大，占用空间也越大
- 创建索引和维护索引降低了增删改效率，因为每次增删改都要动态维护索引，降低了数据的维护速度

## 什么情况下需要创建数据库索引？

- 经常需要查询的列使用索引，可以加快查询速度
- 经常用在连接的列使用索引，可以加快连接速度
- 经常需要排序的列使用索引，可以加快排序查询时间
- 经常跟在 WHERE 后的列使用索引，可以加快条件的判断速度

## MySQL都有哪些索引？(索引的分类？)

按照功能区分：

- **普通索引**：仅加速查询
- **唯一索引**：加速查询 + 列值唯一（可以有null）
- **主键索引**：加速查询 + 列值唯一（不可以有null）+ 表中只有一个

- **全文索引**：对文本的内容进行分词，进行搜索

按照物理存储方式区分：

- **聚集索引（InnoDB 引擎）**：必须要有聚集索引，默认在主键字段上建立聚集索引，如果没有主键，则在第一个非空唯一索引上建立聚集索引
- **非聚集索引（MyISAM 引擎）**

按照组成索引的字段个数区分：

- **单列索引**
- **联合索引（索引建立在多个字段上）**




## 什么是聚集索引？

聚集索引就是按照拼音查询，非聚集索引就是按照偏旁等来进行查询。

其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查"安"字，就会很自然地翻开字典的前几页，因为"安"的拼音是"an"，而按照拼音排序 汉字的字典是以英文字母"a"开头并以"z"结尾的，那么"安"字就自然地排在字典的前部。

如果您翻完了所有以"a"开头的部分仍然找不到这个字，那么就 说明您的字典中没有这个字；

同样的，如果查"张"字，那您也会将您的字典翻到最后部分，因为"张"的拼音是"zhang"。

也就是说，字典的正文部分本身 就是一个目录，您不需要再去查其他目录来找到您需要找的内容。 

我们把这种**正文内容本身就是一种按照一定规则排列的目录称为"聚集索引"**

## 什么是非聚集索引？

如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而 需要去根据"偏旁部首"查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合"部首目录"和"检字表"而查到的字的排序并不是 真正的正文的排序方法，比如您查"张"字，我们可以看到在查部首之后的检字表中"张"的页码是672页，检字表中"张"的上面是"驰"字，但页码却是63 页，"张"的下面是"弩"字，页面是390页。很显然，这些字并不是真正的分别位于"张"字的上下方，现在您看到的连续的"驰、张、弩"三字实际上就是他 们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后 再翻到您所需要的页码。

我们把**这种目录纯粹是目录，正文纯粹是正文的排序方式称为"非聚集索引"。** 
## 聚集索引和非聚集索引有什么区别？

聚集索引和非聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。

聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。

聚集索引（Innodb）的叶节点就是数据节点，而非聚集索引(MyISAM)的叶节点仍然是索引节点，只不过其包含一个指向对应数据块的指针。

## 为什么 InnoDB 引擎默认使用 B+ Tree 实现索引？

它能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数





















