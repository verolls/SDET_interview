# 数据库基础知识

## 什么是关系型数据库？


## 什么是非关系型数据库？

非关系型数据库也叫NoSQL，采用键值对的形式进行存储。

它的读写性能很高，易于扩展，可分为内存性数据库以及文档型数据库，比如 Redis，MongoDB，HBase等等。

适合使用非关系型数据库的场景：

* 日志系统
* 地理位置存储
* 数据量巨大
* 高可用

## 关系型数据库和非关系型数据库的区别是什么？

- 关系型数据库:
  - 容易理解。因为它采用了关系模型来组织数据。
  - 可以保持数据的一致性。
  - 数据更新的开销比较小。
  - 支持复杂查询（带where子句的查询）


- 非关系型数据库:
  - 不需要经过SQL层的解析，读写效率高。
  - 基于键值对，数据的扩展性很好。
  - 可以支持多种类型数据的存储，如图片，文档等等。

## 数据库的三大范式可以讲一下吗？



## 什么是SQL？

## 什么是MySQL？



## MySQL常用的数据类型有哪些？

## MySQL中，一条SQL查询语句是怎么执行的？

1. 客户端请求
2. 连接器：验证用户身份，给予权限
3. 查询缓存：存在缓存则直接返回，不存在则执行后续操作
4. 分析器：对SQL进行词法分析和语法分析操作 
5. 优化器：主要对执行的sql优化选择最优的执行方案方法 
6. 执行器：执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口
7. 去引擎层获取数据返回，如果开启查询缓存则会缓存查询结果


# 数据库引擎


## MySQL常用的存储引擎有什么？它们之间的区别是什么？

InnoDB和MyISAM。
### **InnoDB**

- 是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。
- 实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻影读。
- 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。
- 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。
- 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

### **MyISAM**

- 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。
- 提供了大量的特性，包括压缩表、空间数据索引等。
- 不支持事务。
- 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。

### **总结**

- 事务: InnoDB 是事务型的，可以使用 `Commit` 和 `Rollback` 语句。
- 并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键: InnoDB 支持外键。
- 备份: InnoDB 支持在线热备份。
- 崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性: MyISAM 支持压缩表和空间数据索引。


# 索引

## MySQL为什么要用索引？

- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
- 帮助服务器避免排序和临时表
- 将随机IO变为顺序IO。
- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

## 创建索引有哪些优缺点？

## MySQL都有哪些索引？

## 什么时候创建索引？

## 索引什么时候失效？

## 什么是聚集索引？什么是非聚集索引？

## 什么是主键？什么是外键？

## 慢查询是什么原因导致的？如何排查慢查询？

## B/B+树的原理和区别？

## 为什么要用B+树？为什么不用红黑树？为什么不用跳表？

文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。

最重要的是，B+树还有一个最大的好处：方便扫库。

B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。

B+树查找效率更加稳定，B树有可能在中间节点找到数据，稳定性不够。



B+tree的磁盘读写代价更低：B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；

B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；

# 事务

## 为什么需要事务？什么是事务？

- 事务是数据库并发控制的基本单位
- 事务可以看作是一系列SQL语句的集合
- 事务要么全部执行成功，要么全部执行失败(回滚)

## 事务的四个基本特性是什么？

ACID是事务的四个基本特性：

- 原子性(Atomicity): 一个事务中所有操作全部完成或失败
- 一致性(Consistency): 事务开始和结束之后数据完整性没有被破坏
- 隔离性(Isolation): 允许多个事务同时对数据库修改和读写
- 持久性(Durability): 事务结束之后，修改是永久的，不会丢失

## 数据库并发事务时，如果不对事务进行并发控制，会产生哪些异常？(你知道哪些并发控制异常？)

数据库并发会带来脏读、幻读、丢弃更改、不可重复读这四个常见问题，其中：

**脏读**：举例：第一个事务首先读取var变量为50，接着更新为100，但并未提交，第二个事务已经读取var为100，此时第一个事务做了回滚。最终第二个事务读取的var和数据库的var不一样。

**幻读**：T1 读取某个范围的数据，T2 在这个范围内插入或删除新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。强调范围。

**丢弃修改**：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。例如：事务1读取某表中的数据A=50，事务2也读取A=50，事务1修改A=A+50，事务2也修改A=A+50，最终结果A=100，事务1的修改被丢失。

**不可重复读**：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。  

## 不可重复读和幻读区别是什么？可以举个例子吗？

**不可重复读的重点是修改，幻读的重点在于新增或者删除。**

- 例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为 2000；这就是不可重复读。

- 例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记 录就变为了5条，这样就导致了幻读。


## 如何解决并发控制异常？(你知道哪些事务隔离级别？)

为了解决并发控制异常，定义了四种事务隔离级别:

- 读未提交(read uncommitted): 别的事务可以读取到未提交改变
- 读已提交(read committed): 只能读取已经提交的数据
- 可重复读(repeatable read): 同一个事务先后查询结果一样
- 串行化(serializable): 事务完全串行化的执行，隔离级别最高，执行效率最低

>“是”表示会出现这种问题，“否”表示不会出现这种问题

级别	|名字	|隔离级别	|脏读	|不可重复读	|幻读	
--|--|--|--|--|--
1	|读未提交	|read uncommitted|	是	|是	|是
2	|读已提交	|read committed	|否	|是	|是	
3	|可重复读|	repeatable read|	否	|否	|是	
4	|串行化	|serializable	|否	|否	|否|


隔离级别越高，安全性越高，但性能越差。

## 如何解决高并发场景下的数据重复插入问题？

- 使用数据库的唯一索引
- 使用队列异步写入
- 使用Redis实现分布式锁

# 锁

## 什么是乐观锁？什么是悲观锁？


## 乐观锁和悲观锁的使用场景是什么？




















