# 测试基础知识
## 什么是软件测试，软件测试的目的是什么？
为了发现程序中的错误而执行程序的过程就是软件测试。

软件测试的目的是按照软件需求，找出软件中存在的错误，发现软件的缺陷，帮助改进软件。

## 为什么选择测试
无论在哪个行业，产品的质量是第一位的，测试工程师的主要工作就是发现程序中的错误，撰写测试报告，进而保证产品质量。因此测试工程师这一岗位一定是不可或缺的。
要想做好测试的工作，非常需要耐心和细心两个品质，需要发散的思维去对测试对象进行“破坏”。我认为我具备耐心与细心的品质。
通过实习，我掌握了测试用例的设计，能够使用Python来实现Web自动化测试脚本的编写。
因此，我选择这个岗位。

## 软件测试的流程
- 测试需求分析阶段：阅读需求，理解需求，分析需求点，参与需求评审会议
- 测试计划阶段：参考软件需求编写测试计划，内容包括测试范围（来自需求文档），进度安排，人力物力的分配，整体测试策略的制定。
- 测试设计阶段：参考需求文档编写测试用例，用例编写完成之后会进行评审。
- 测试执行阶段：搭建测试环境，执行测试，bug管理直到测试结束
- 测试评估阶段：出测试报告，确认是否可以上线

## 常见的测试模型
V模型

![../ImageHost/测试开发常用知识点/V模型.jpg](../ImageHost/测试开发常用知识点/V模型.jpg)

W模型

![../ImageHost/测试开发常用知识点/W模型.png](../ImageHost/测试开发常用知识点/W模型.png)

## 测试方法分类
### 按测试阶段划分
- 单元测试：单元测试属于白盒测试，单元测试是最微小规模的测试，是对软件中的单元模块进行测试，测试的是某个功能或代码块。
- 集成测试：集成测试属于灰盒测试，集成测试又称为组装测试，就是在单元测试的基础上，对单元模块之间的接口进行测试。
- 系统测试：系统测试属于黑盒测试，主要测试系统是否符合需求，包括对功能、性能，以及软件所运行的软硬件环境进行测试。
- 验收测试：验收测试是基于客户或最终用户的规格书的最终测试，或基于用户一段时间的使用后，看软件是否满足客户要求。一般从功能、用户界面、性能、业务关联性进行测试。
- 回归测试：回归测试是指在发生修改之后重新测试，目的是验证新增的功能是否引入新的问题，旧的缺陷是否修复成功。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。

### 验收测试中的测试方法
- α测试：在软件发布前，由开发机构人员来模拟潜在用户开展的测试，则称为α测试。
- β测试：软件的早期版本被发布给具有代表性用户群来测试，称为β测试


### 按是否查看程序内部结构划分
- 白盒测试：对软件内部的逻辑结构进行详细检查，对程序的所有逻辑进行测试。
- 黑盒测试：把测试对象看成一个黑盒子，不需要考虑程序内部的逻辑结构，只需要依照程序的需求规格说明书，检查程序功能是否能够实现即可。黑盒测试又分为功能测试和性能测试。功能测试检查实际软件的功能是否符合用户的需求。包括逻辑功能测试、界面测试、易用性测试和兼容性测试。性能测试主要有时间性能和空间性能两种。其中，时间性能主要指软件的一个具体事务的响应时间，而空间性能主要指软件运行时所消耗的系统资源。
- 灰盒测试：是介于白盒测试和黑盒测试之间的一种测试，不仅关注输出输入情况，也关注程序内部的逻辑。

### 功能测试中的测试方法
- 冒烟测试：对软件基本功能的测试
- 兼容性测试：兼容测试主要是检查软件在不同的平台上是否可以正常的运行，即是通常说的软件的可移植性。兼容性测试属于非功能性测试，我们拿到一个产品时，应优先保证功能性测试的验证，再去兼顾其它非功能性测试。


### 性能测试中的测试方法
- 负载测试：负载测试是通过改变系统负载方式、逐渐增加负载等来发现系统中所存在的性能问题。负载测试是一种测试方法，可以为性能测试、压力测试所采用。

- 压力测试：压力测试通常是在高负载情况下来对系统的稳定性进行测试，更有效地发现系统稳定性的隐患和系统在负载峰值的条件下功能隐患等。


### 按是否运行程序划分
- 静态测试：静态测试指测试不运行的部分，只是静态地检查程序代码、界面或文档可能存在的错误的过程。例如测试产品说明书，对此进行检查和审阅.。
- 动态测试：动态测试是指通过运行软件来检验软件的动态行为和运行结果的正确性。具体操作就是输入相应的测试数据，检查输出结果和预期结果是否相符的过程。

### 按测试执行方式划分
- 手动测试：人工执行测试
- 自动化测试：软件测试自动化，目的是节省人力、时间或硬件资源，提高测试效率

## 灰度测试和A/B测试是什么？它们之间有什么区别？    
灰度测试
- 灰度测试：**在某项应用正式发布前**，选择特定人群试用，逐步扩大其试用者数量，以便及时发现和纠正其中的问题。(做灰度测试需要选择适合的用户，需要基于随机原则)   
例如：某应用升级了视频资源的播放格式，但不知道新版本是否有问题。那么该应用可以通过配置下发，控制一部分用户的应用去播放新格式的视频。然后通过监控来观测播放成功率和卡顿率等，一旦有问题会立即回滚。  


- A/B测试：AB测试是为某个应用制作两个（A/B）或多个（A/B/n）版本，在同一时间维度，分别让组成成分相同（相似）的访客群组（目标人群）随机地访问这些版本，收集各群组的用户体验数据和业务数据，最后分析、评估出最好版本，正式采用。    
例如：某应用换皮肤，可以把两种待选皮肤都投入市场，看哪种皮肤的按钮用户点击量大，用户停留时长高。  

区别：
- 灰度测试本质上是上线前的测试，收集用户的反馈。A/B测试本质上是上线后的测试，收集用户的反馈。
- AB的两种功能都是可用的，投放的用户群体无差别，让用户选择更受欢迎的功能。目标不明确，后期可能是A上线，也可能是B上线。灰度版本未必是可用的，或者说没有严重bug的，投放的客户群体可能被选择和约束（例如只投放安卓低端机），由监控确定是否有问题，目标明确，只要灰度版本没问题，就会继续放量上线，直到全量。

## 黑盒测试中测试用例的设计方法有哪些
有基于需求的设计方法、等价类划分、边界值分析、因果图、判定表。
### 基于需求的设计方法：
- 定义：依据客户需求设计测试用例，但是在设计的过程中一定要辩证的看待需求（即：需求不一定都是正确的）
### 等价类划分法
- 定义：依据需求将输入划分为若干等价类，从等价类中选定一个测试用例，如果该测试用例通过，则表明整个等价类通过测试。
- 适用场景：对于等价类这个方法，一般适用于有无限多种输入，我们不可能完成穷举测试，等价类可以使我们用较少的测试用例尽可能多的将功能覆盖。
- 一般划分为：有效等价类、无效等价类。有效等价类：有意义的输入构成的集合，对于需求规格说明书是合法的；无效等价类：不满足需求的集合。
### 边界值分析法
- 定义：边界值法是对输入数据的边界测试，一般来说边界值法是对等价类划分后的补充。

- 举例：
对于设定密码的测试，要求密码必须为6-15位
分析过程：有效等价类为>=6 && <=15 无效等价类为：<6 || >15
设定边界值：5、6、10、15、16
>- 解释：
>- 6和15作为有效等价类中的内容，又是边界值，可以判定有效等价类的内容是否满足要求
>- 但是6和15又很特殊，它不仅代表了有效等价类，还代表了边界值，所以我们选定一个普通的有效等价类作为一个测试用例，如：10
>- 5和16作为无效等价类中的内容，又是边界值（比4或者17更具有代表性），可以判定无效等价类的内容


### 因果图
- 定义：因果图是从需求中找出因（输入条件）和果（输出或程序改变的状态），通过因果图转化为判定表。

- 使用因果图法设计测试用例的步骤：
  1. 确定软件规格(需求)中的原因和结果
  2. 确定原因和结果之间的逻辑关系
  3. 确定因果图中的各个约束(constraints)
  4. 画出因果图并转换为判定表
  5. 根据判定表设计测试用例

### 判定表

- 定义：判定表是分析和表达多逻辑条件下执行不同操作的情况的工具，能够将复杂的问题按照各种可能的情况全部列举出来。
- 判定表由四部分组成：
  - 条件桩：可能出现这个问题的所有条件
  - 条件项：条件桩的取值
  - 动作桩：这个问题的所有输出结果
  - 动作项：条件项的各个取值情况下的输出结果。

|条件桩|条件项|
|--|--|
|动作桩|动作项|

- 使用判定表法设计测试用例的步骤：
  1. 列出所有的条件桩和动作桩，填入条件项，填入动作项，得到初始判定表
  2. 简化判定表，合并相似规则。
     - 若表中有两条以上规则具有相同的动作，并且在条件项之间存在极为相似的关系，便可以合并。
     - 合并后的条件项用符号“-”表示，说明执行的动作与该条件的取值无关，称为无关条件。 
  3. 设计测试用例
- 举例：
要求对功率大于50马力的机器或维修纪录不全且已运行10年以上的机器，应给予优先维修处理，请利用判定表法设计测试用例。

1. 列出所有条件桩、动作桩。填入条件项、动作项，得到初始判定表。
<table>
	<tr>
	    <td rowspan="3">条件桩</td>
	    <td>功率大于50马力吗？</td>
	    <td>1</td>  
        <td>1</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>0</td> 
        <td>0</td> 
        <td>0</td> 
	</tr >
	<tr >
	    <td>维修记录不全？</td>
	    <td>1</td>  
        <td>1</td> 
        <td>0</td> 
        <td>0</td> 
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
        <td>0</td> 
	</tr>
	<tr>
	    <td>运行超过10年吗？</td>
	    <td>1</td>  
        <td>0</td> 
        <td>1</td> 
        <td>0</td> 
        <td>1</td> 
        <td>0</td> 
        <td>1</td> 
        <td>0</td> 
	</tr>
	<tr>
	    <td rowspan="2">动作桩</td>
	    <td>进行优先维修</td>
	    <td>X</td>  
        <td>X</td> 
        <td>X</td> 
        <td>X</td> 
        <td>X</td> 
        <td></td> 
        <td></td> 
        <td></td> 
	</tr>
	<tr>
	    <td>不进行优先维修</td>
	    <td></td>  
        <td></td> 
        <td></td> 
        <td></td> 
        <td></td> 
        <td>X</td> 
        <td>X</td> 
        <td>X</td> 
	</tr>
</table>
 
  2. 简化判定表。

<table>
	<tr>
	    <td rowspan="3">条件桩</td>
	    <td>功率大于50马力吗？</td>
	    <td>1</td>  
        <td>0</td> 
        <td>0</td> 
        <td>0</td> 
	</tr >
	<tr >
	    <td>维修记录不全？</td>
	    <td>-</td>  
        <td>1</td> 
        <td>1</td> 
        <td>0</td> 
	</tr>
	<tr>
	    <td>运行超过10年吗？</td>
        <td>-</td> 
        <td>1</td> 
        <td>0</td> 
        <td>-</td>
	</tr>
	<tr>
	    <td rowspan="2">动作桩</td>
	    <td>进行优先维修</td>
	    <td>X</td>  
        <td>X</td> 
        <td></td> 
        <td></td> 
	</tr>
	<tr>
	    <td>不进行优先维修</td>
	    <td></td>  
        <td></td> 
        <td>X</td> 
        <td>X</td> 
	</tr>
</table>

3. 得出测试用例

| 用例序号 | 输入 | 预期输出 |
|--|--|--|
| 1 | 无论维修记录是否齐全，是否运行超过10年，只要功率大于50马力的情况 | 进行优先维修|
| 2 | 功率没有大于50马力，但维修记录不全且已运行超过10年的情况 | 进行优先维修 |
| 3 | 当功率没有大于50马力和维修记录不全时，但运行没有超过10年的情况 | 不进行优先维修
| 4 | 无论运行是否超过10年，当功率没有大于50马力和维修记录不全的情况 | 不进行优先维修 |

## 黑盒测试用例设计时，选定某种方法的依据是什么？
- 等价类划分法和边界值分析方法都是着重考虑输入条件。如果程序输入之间没有什么联系，采用等价类划分和边界值分析是一种比较有效的方法。
- 因果图法和判定表法着重测试规格说明中的输入与输出间的依赖关系。如果输入之间有关系，例如，约束关系、组合关系，这种关系用等价类划分和边界值分析是很难描述的，测试效果难以保障，因此必须考虑使用一种适合于描述对于多种条件的组合，产生多个相应动作的测试方法，那么可以采用因果图法和判定表法。


## 白盒测试中测试用例的设计方法有哪些？
有逻辑覆盖法和基本路径法，其中逻辑覆盖法分为：语句覆盖、判定覆盖、条件覆盖、判定-条件覆盖、条件组合覆盖与路径覆盖。
- 语句覆盖：在测试时，首先设计若干个测试用例，然后运行被测程序，使程序中的每个可执行语句至少执行一次。
>优点：可以很直观地从源代码得到测试用例，无须细分每条判定表达式。
缺点：语句覆盖是最弱的覆盖，仅仅针对程序逻辑中显式存在的语句，但对于隐藏的条件和可能到达的隐式逻辑分支，是无法测试的。
- 判定覆盖法：在测试时，首先设计若干个测试用例，然后运行被测程序，使得程序中的每个判定的取真分支和取假分支至少经历一次，即判定的真假值均曾被满足。
>优点：判定覆盖具有比语句覆盖更强的测试能力。同样判定覆盖也具有和语句覆盖一样的简单性，无须细分每个判定就可以得到测试用例。
缺点：大部分判定语句是由多个逻辑条件组合而成。若仅仅判断其整个最终结果，而忽略每个条件的取值情况，必然会遗漏部分测试路径。
- 条件覆盖法：在测试时，首先设计若干个测试用例，然后运行被测程序，要使每个判定语句中每个条件的可能取值至少满足一次。
>优点：条件覆盖相比于判定覆盖，增加了对符合判定情况的测试，增加了测试路径。
缺点：条件覆盖并不能保证判定覆盖。条件覆盖只能保证每个条件至少有一次为真，而不考虑所有的判定结果。
- 判定条件覆盖法：在测试时，首先设计若干个测试用例，然后运行被测程序，使得判定中每个条件的所有可能至少出现一次，并且每个判定本身的判定结果至少出现一次。
>优点：判定条件覆盖法满足判定覆盖准则和条件覆盖准则，弥补了二者的不足。
缺点：未考虑条件的组合情况。
- 条件组合覆盖法：在测试时，首先设计若干个测试用例，然后运行被测程序，使得每个判定中每个条件的各种组合都至少被执行一次。
>优点：满足条件组合覆盖的测试用例一定满足判定覆盖、条件覆盖和判定条件覆盖。
缺点：线性地增加了测试用例的数量。
- 路径覆盖法：在测试时，首先设计若干个测试用例，然后运行被测程序，要求覆盖程序中所有可能的路径。
>优点：覆盖程度最高，因为其覆盖程序中所有可能的路径。
缺点：对于比较简单的小程序来说，实现路径覆盖是可能的，但是如果程序中出现了多个判断和多个循环，可能的路径数目将会急剧增长，以致实现路径覆盖是几乎不可能。

总结：

- 覆盖程度：路径覆盖>条件组合覆盖>判定条件覆盖>条件覆盖>判定覆盖>语句覆盖
- 用例复杂程度：路径覆盖>条件组合覆盖>判定条件覆盖>条件覆盖>判定覆盖>语句覆盖

举例：

```python
a, b, x = list(map(int,(input('输入a，b，x的值，以空格为分割').strip().split())))

if (a > 1 and b == 0):
    x = x / a
if (a == 2 or x > 1):
    x += 1
```

上述程序的程序流程图为：

![在这里插入图片描述](../ImageHost/测试开发常用知识点/白盒测试举例流程图.png)

- 语句覆盖：

  - 需要执行的可执行语句共有四条，因此覆盖路径a-c-e即可覆盖这四条可执行语句。
  - 设计测试用例如下：
    - a=2, b=0, x=4   覆盖路径：a-c-e  

- 判定覆盖：

  - 需要覆盖判定路径：(a-c-e、a-b-d) 或 (a-b-e、a-c-d)
  - 设计测试用例如下：
    - a=2, b=0, x=4   覆盖路径：a-c-e  
    - a=0, b=0, x=1   覆盖路径：a-b-d

- 条件覆盖：

  - 需要满足判定语句中的条件：
    - 判定1的条件取值(a>1, a<=1, b=0, b!=0) 
    - 判定2的条件取值(a=2, a!=2, x>1, x<=1)
  - 设计测试用例如下：
    - a=2, b=0, x=4   覆盖条件(a>1, a=2, b=0, x>1)
    - a=1, b=1, x=1   覆盖条件(a<=1, b!=0, x<=1) 

- 判定条件覆盖：
  - 需要满足的判定条件为：
    - 需要覆盖判定路径：(a-c-e、a-b-d) 或 (a-b-e、a-c-d)
    - 需要满足判定语句中的条件：
      - 判定1的条件取值(a>1, a<=1, b=0, b!=0) 
      - 判定2的条件取值(a=2, a!=2, x>1, x<=1)
  - 设计测试用例如下：
    - a=2, b=0, x=4   覆盖路径a-c-e，覆盖条件(a>1, a=2, b=0, x>1)
    - a=1, b=1, x=1   覆盖路径a-b-d，覆盖条件(a<=1, b!=0, x<=1)

- 条件组合覆盖：

  - 需要满足的条件组合为：
    1. a>1, b=0
    2. a>1, b!=0
    3. a<=1, b=0
    4. a<=1, b!=0
    5. a=2, x>1
    6. a=2, x<=1
    7. a!=2, x>1
    8. a!=2, x<=1

  - 设计测试用例如下：
     - a=2, b=0, x=4 覆盖组合1，5
     - a=2, b=1, x=1 覆盖组合2，6
     - a=1, b=0, x=3 覆盖组合3，7
     - a=1, b=2, x=1 覆盖组合4，8

- 路径覆盖：

  - 需要覆盖的路径为：a-c-e、 a-b-d、 a-b-e、 a-c-d
  - 设计测试用例如下：
    - a=2, b=0, x=4 覆盖路径：a-c-e
    - a=1, b=0, x=1 覆盖路径：a-b-d
    - a=2, b=1, x=1 覆盖路径：a-b-e
    - a=3, b=0, x=4 覆盖路径：a-c-d


## 从哪几个维度设计测试用例？
功能，性能，界面，安全，兼容性，网络，专项测试

## 一条bug记录应该包括哪些内容？
bug编号；  
bug优先级；  
bug出现的环境(如测试环境、生产环境)；  
bug产生的模块；  
bug详细现象描述，如使用截图、录像等进行描述；  
bug详细复现步骤。  

## 如果你发现一个bug，怎么判断是前端问题还是后端问题？
通过抓包工具(比如fiddler、charles、开发者工具)抓取接口数据，如果接口数据没有问题，则bug属于前端问题，如果接口数据有问题，可能是后端问题。

## 如果你发现了一个bug，怎么推动开发去修改？
我认为优先级高的bug，需要及时推动开发去修改。  
因此，首先定下bug的优先级，这个bug是否属于需要立即修改的bug，即这个bug是否会延误产品的上线时间。  
如果bug优先级高，和开发人员沟通，强调bug的优先级。然后协助开发查找定位bug，帮忙减轻开发人员的负担。  
但是优先级相对低的bug，也需要及时推动开发去修复。

## 有没有遇到过发现bug，但开发认为不是bug的情况，你是怎么解决的？
有遇到过。  
首先参考产品需求文档，尝试再次复现，确定是否是bug。  
若确认是bug，检查自己提交的bug记录，是不是自己描述的不准确。  
跟开发人员对照产品需求文档进行沟通。  
若仍存在争议，需要产品经理介入，一起讨论。

## 什么是C/S模式？优缺点是什么？
C/S模式即客户端-服务器模式。  
PC端上，除浏览器外和服务器有交互的软件都是C/S模式，例如QQ、杀毒软件、网络游戏客户端等。  
手机端上，如QQ、微信等和服务器有交互的软件都是C/S模式。  
C/S模式的优点是可以相对灵活地实现各种预期的功能和效果。  
C/S模式的缺点是大部分功能新增、界面调整、逻辑变更都需要更新客户端来实现。

## 什么是B/S模式？优缺点是什么？
B/S模式即浏览器-服务器模式。  
PC端上，浏览器和访问的网站即为B/S模式，例如Chrome、各类网站等。  
手机端上，手机上的浏览器、手机访问的网站即为B/S模式，例如UC浏览器、Chrome浏览器、各类网站等。  
B/S模式的优点是可以灵活实现功能变更、界面布局调整、逻辑变更、内容动态变更等。  
B/S模式的缺点是，受限于浏览器的能力，许多特殊效果无法通过浏览器实现。  
## 工作中常用英文缩写
|简称|全称|翻译|备注
|--|--|--|--|
B2B | Business to Business | 企业对企业的电子商务 
B2C | Business to Customer | 企业对个人的电子商务
C2C | Customer to Customer | 个人对个人的电子商务
|SPU|Standard Product Unit|标准产品单元|描述了一种产品的宏观概念，例如：年会员礼品卡。|
|SKU|Stock Keeping Unit|库存量单元|物理上不可分割的最小存货单元，几种SKU可能具备同一个SPU，例如：年会员礼品卡×1；年会员礼品卡×5；年会员礼品卡×100，这三个SKU都具备同一个SPU，即"年会员礼品卡"。|   
|DAU|Daily Active User|日活跃用户数量|日活跃用户数量通常统计一日（统计日）之内，登录或使用了某个产品的用户数（去除重复登录的用户）。受统计方式限制，互联网行业使用的日均活跃用户数指在统计周期(周/月)内，该App的每日活跃用户数的平均值。|
|MAU|Monthly Active User|月活跃用户数量|受统计方式限制，互联网行业使用的月活跃用户数一般指在统计周期(周/月)内，启动过该App的用户数。活跃用户数按照用户设备维度进行去重统计，即在统计周期(周/月)内至少启动过一次该App的设备数。|
PV | Page View | 页面浏览量 | 通常用来衡量一个网站的主要指标
ROI | Return On Invertment | 投资回报率 | 花出去的多少钱转换为了企业的价值
BRD | Business Requirement Document | 商业需求文档
MRD | Market Requirement Document | 市场需求文档
PRD | Product Requirement Document | 产品需求文档



# 测试用例设计
## 如何测试App
- 功能：根据产品的需求文档，针对性地进行测试；
- 性能：App最大支持的用户并发数量。
- 安全：对app的登录界面进行测试，查看敏感信息是否加密。
- 兼容：测试不同操作系统（android、ios等，每个还包含多个版本）、不同厂家手机（华为、小米和苹果等）、不同屏幕尺寸的兼容性；新功能在App的旧版本上进行测试。
- 网络：断网或弱网或切换网络环境进行测试。
- 专项测试：异常场景测试(前后台切换、来电、短信、关机、重启)、App的安装与卸载测试。



## 如何测试Web
- 功能：根据产品的需求文档，针对性地进行测试；
- 性能：Web响应时间测试；某个时刻同时访问Web系统的最大用户数量测试
- 界面：Web导航是否直观，风格是否符合大众审美
- 安全：查看用户登录的功能是否安全
- 兼容：测试不同操作系统（比如windows、MAC和linux等，每个还包含多个版本）、不同浏览器（比如IE、chrome和firefox等）、不同分辨率的兼容性

## App测试和Web测试的区别
- 架构：web 项目 ，一般都是b/s架构，基于浏览器的。App则是C/S的，必须要有 客户端 。那么在系统测试测试的时候就会产生区别。
首先从系统架构来看的话，Web测试只要更新了服务器端， 客户端 就会同步会更新。而且 客户端 是可以保证每一个用户的 客户端 完全一致的。但是App端是不能够保证完全一致的，除非用户更新 客户端 。如果是App下修改了服务端，意味着 客户端 用户所使用的核心版本都需要进行回归测试一遍。
- 性能：Web页面关注响应时间。App还需要关心流量、电量、CPU、GPU、Memory等。
- 兼容性：Web是基于浏览器的，而浏览器的兼容一般选择不同的浏览器内核进行测试（IE、chrome、Firefox）。App的测试则必须依赖手机或者是平板，需要考虑分辨率，屏幕尺寸，设备系统的兼容性。
- 专项测试：相比较Web测试，App多了一些专项测试。比如异常场景测试(中断、来电、短信、关机、重启)、弱网测试(弱网、网络切换)、安装、卸载测试。

## App测试和小程序测试的区别
- 下载渠道及安装卸载不同
小程序： 主要通过扫二维码、用户分享推荐、搜索小程序等获取；并且不需下载安装，清除时直接删除小程序
APP: 需要去应用市场下载；并且安装后才能使用，清除时需卸载
- 开发周期及发布审核不同
小程序：一个版本可兼容不同的手机平台，小程序的开发周期约2周；发布审核时周期较短
APP： 支持的android和ios平台需分别开发，周期较长大约3个月；且在各大应用商店发布的审核周期也较长
- 登录权限不同
小程序：一般授权微信登录，无需注册；例如微信未授权/授权登录程序，同一微信号不同手机登录查看数据是否同步显示；
APP：需要注册登录系统，权限方面需要考虑是否可以访问手机通讯录、相册、相机等权限；
- 兼容性测试不同：
小程序：基于不同的公众平台，比如微信，主要兼容不同的微信版本
APP：考虑不同机型的兼容，不仅要看分辨率，屏幕尺寸，还要看操作系统

## 如何测试一个登录窗口
- 功能：1. 什么都不输入，点击登录，查看提示信息；2. 输入正确的用户名及密码，点击登录，查看提示信息；3. 输入错误的用户名或错误的密码，点击登录，查看提示信息；4. 若登录成功，查看是否能跳转到正确的界面；5. 输入过短或过长的用户名，查看提示信息；6. 输入过短或过长的密码，查看提示信息；7. 用户名或密码输入不允许输入的字符，点击登录，查看提示信息；8. 输入密码时，切换大小写，查看是否有大小写提示信息。9. 记住用户名的功能
- 性能：模拟大量用户同时登录，检查一定压力下能否正常登录跳转
- 界面：用户名输入框与密码输入框布局是否合理，按钮大小是否合理。
- 安全：用户名和密码的输入框，应该屏蔽SQL注入攻击，禁止输入脚本(防止XSS攻击)；密码输入次数是否有上限，达到上限次数后，是否有冷却期；同一用户是否可以在多台计算机上登录
- 兼容：1. 若登录界面是web端，则测试此登录窗口在不同的浏览器中能否正常工作；2. 若登录界面是客户端，则测试此客户端在不同操作系统中能否正常使用；3. 若登录界面是移动端app，则测试此app能否在不同系统的设备中使用。

## 如何测试搜索框
- 功能：搜索内容为空，查看提示信息；搜索内容为空格，查看提示信息；输入超长字符串，查看提示信息，验证系统是否会截取允许最大长度来进行搜索；输入合法长度字符串后，加空格验证搜索结果；是否支持回车搜索；输入敏感词汇后，是否提示用户无权限搜索；是否有搜索历史
- 性能：搜索页面的打开速度是否满足设计要求
- 界面：搜索框UI以及按钮布局是否合理美观
- 安全：应该屏蔽SQL注入；应该禁止输入脚本；禁止搜索敏感内容
- 兼容：1. 若搜索框是web端，则测试此登录窗口在不同的浏览器中能否正常工作；2. 若搜索框是客户端，则测试此客户端在不同操作系统中能否正常使用；3. 若搜索框是移动端app，则测试此app能否在不同系统的设备中使用。

## 手机扫描二维码如何测试
二维码基础知识：二维码本身就是一个URL，只是通过QR码的形式把URL和用户身份信息转换成二进制的0和1，二维码中黑色的色素块代表1，白色的色素块代表0，我们通过相机扫码，就获取了二维码中的URL

- 功能：扫描成功是否有提示；扫描失败是否有提示；只扫描一半二维码是否能够扫描成功；打开扫描功能一段时间后没有扫描任何二维码，是否有提示用户或自动退出扫描功能；是否支持相册获取二维码；当扫描不是二维码时提示是否正确；同时扫描多个二维码
- 性能：扫描二维码后的响应时间；
- 界面：界面的按钮与文字说明是否清晰正确；界面设计风格是否符合大众审美
- 安全：扫码是否会泄露用户敏感信息
- 兼容：使用不同操作系统的手机扫码；使用不同品牌的手机扫码
- 网络：断网扫码；弱网扫码
- 专项：扫描二维码过程中的中断测试(前后台切换、来电、短信、关机等)

## 如何测试杯子
- 功能：杯子漏不漏水；用户喝水方不方便；
- 性能：检查杯子从不同高度落下后的损坏程度；将杯子装满水，24小时后检查泄露情况；
- 界面：杯子外观是否符合大众审美
- 安全：检查杯子自身细菌是否超标，是否会对用户健康造成影响；杯子是否有防滑措施
- 兼容：检查杯子在不同温度下的使用情况；杯子是否可以装多种液体。



# 自动化测试知识

## 自动化测试的目的(自动化测试的优点)
1. 提高测试效率
2. 降低人力物力成本
3. 完成人工难以实现的测试，比如模拟数百万级别用户访问的性能测试
4. 更有效率的执行回归测试

## 自动化测试的缺点
1. 适用范围较窄，一般只在回归测试中使用。
2. 编写自动化测试脚本的时间远大于功能测试用例
3. 无法对界面的美观程度进行测试

## 开展自动化测试的主要流程一般是？

1. 定义自动化测试覆盖范围
2. 制定自动化测试计划
3. 搭建自动化测试环境
4. 脚本开发
5. 执行测试脚本
6. 测试脚本维护

## 你了解哪些常见的自动化测试框架
- Selenium：做Web端的自动化测试
- Appium：做移动端App的自动化测试
- Jmeter：做接口自动化测试，做性能测试

## 你了解哪些常见的单元测试框架
- TestNG：Java用
- Unittest：Python用
- Pytest：Python用

## 什么功能适合自动化测试？
- 功能改动小的。如果功能改动频繁，测试人员就需要根据改动的需求频繁修改测试脚本，甚至需要修改底层的自动化测试框架。
- 需要经常做回归测试的功能。一般在项目迭代版本时，需要经过一遍全流程的回归测试，这样会占用大量的人力物力，若将回归测试交由自动化脚本进行测试，将节省大量的人力物力。
- 重复、机械性的功能
- 需要频繁测试的功能

## 什么功能不适合自动化测试？

- 项目周期短，测试用例不会重复多次执行
- 被测项目不稳定，变化频繁

## 自动化测试可以达到100%的覆盖率吗？

比较难以达到。

1. 有一些用例场景不适合做自动化，例如验证功能的易用性和友好性。
2. 某些边缘的测试用例很少被重复执行，不适合做自动化。

## 什么是测试用例？什么是测试脚本?两者的关系是什么？
- 测试用例是为实施测试而向被测试系统提供的输入数据、操作或各种环境设置以及期望结果的一个特定的集合。
- 测试脚本是为了进行自动化测试而编写的脚本。
- 测试脚本的编写必须对应相应的测试用例。

## 对 Web 页面进行自动化测试时，如果页面元素经常发生变化，如何做？

使用 POM 开发自动化测试脚本。


## 什么是POM(Page Object Model)？

POM全称是 Page Object Model，是一种设计模式，一种思想。

具体实现的方式是，把**页面元素、对元素的操作**和**测试脚本**分离出来至**页面类**和**脚本类**两个类文件中。

![../ImageHost/测试开发常用知识点/POM模型.jpg](../ImageHost/测试开发常用知识点/POM模型.jpg)

![../ImageHost/测试开发常用知识点/POM示例.png](../ImageHost/测试开发常用知识点/POM示例.png)

**页面类**编写对页面元素操作的方法，**脚本类**调用页面类定义的方法来编写测试脚本。

如果前端页面发生变化，测试的逻辑不变，只需更改**页面类**中的方法即可，不需要更改**脚本类**中的测试脚本。
## 使用 POM 的好处是什么？

1. 实现业务代码和测试脚本分离，降低了自动化测试脚本的维护成本。
2. 页面类的代码可以复用，减少了测试脚本代码量。
3. 层次清晰，可多人同时进行自动化脚本开发，例如每个人写不同的页面类，不会相互影响。
# Charles 常用知识

# Postman 常用知识

# TestNG 常用知识

## 什么是 TestNG

TestNG是Java的单元测试框架。
- TestNG提供了注解功能，利用注解可以非常方便的组织测试用例的执行顺序。
- TestNG还具有断言机制，可以利用断言来验证检查点。
- TestNG提供HTML格式的测试报告。

## 利用 TestNG 编写测试用例的完整步骤？

1. 插入TestNG注解
2. 在注解下编写自动化测试脚本
3. 配置TestNG.xml文件，在文件内定义要运行的测试用例
4. 执行TestNG
5. 查看测试报告

## TestNG 常用的注解有哪些？

- @BeforeTest
- @AfterTest
- @Test

## TestNG 如何设定测试步骤之间的依赖关系？

在 @Test 注解中加入 `dependsOnMethods` 属性实现测试步骤之间的依赖关系。

属性的值就是该测试步骤所依赖的方法，可以指定一个方法，也可以指定若干个方法，若指定若干个方法，则方法之间用逗号分隔。

意思就是需要先运行指定的依赖方法后，才能运行当前测试步骤。

如果不设定依赖关系，存在多个 @Test 时，将按照方法名的升序来执行。

## TestNG 如何设定测试步骤优先级？

在 @Test 注解中加入 `priority` 属性来设定测试步骤执行的优先级。

属性的值越低，优先级越高。

如果不设定优先级，存在多个 @Test 时，将按照方法名的升序来执行。

## TestNG 中如何忽略一个测试步骤的执行？

在 @Test 注解中加入 `enabled` 属性来设定该测试步骤是否应该执行。

若设定属性的值为 `false`，执行测试用例时，TestNG 就会忽略该测试步骤。


# Pytest 常用知识