# Java基础知识

## Java与Python的相同点与不同点是什么？
相同点：
- 两者都是面向对象语言。
- 两者都是强类型语言。
  - 也就是一旦一个变量被指定了某个数据类型，如果不经过强制类型转换，那么它就永远是这个数据类型。
- 两者都是解释型语言。
  - 解释型语言有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。但是解释型语言在运行的时候都要解释一遍，性能上不如编译型语言。
    - Python代码运行时，会先编译（翻译）成中间代码，每个 .py 文件将被换转成 .pyc 文件，.pyc 就是一种字节码文件，它是与平台无关的中间代码，不管你放在 Windows 还是 Linux 平台都可以执行，运行时将由虚拟机逐行把字节码翻译成目标代码。
    - Java运行时，先将源代码编译成字节码`.class`文件，然后运行时，JVM再将字节码翻译成机器语言。也正是因为这样，java可以跨平台，根据不同的操作系统翻译对应的机器语言。

不同点：
- Python是动态类型语言，Java是静态类型语言。
  - 动态类型语言是指在运行期间才去做数据类型检查的语言，在用动态类型的语言编程时，永远不用给任何变量指定数据类型。
  - 静态类型语言的数据类型是在编译期间检查的，也就是说在写程序时要声明所有变量的数据类型。
- Python编写代码时，代码末尾不需要加分号，Java则需要加分号。
- Python通过缩进控制代码逻辑，Java通过大括号来控制逻辑，但是缩进是否合理会影响代码的可读性。

## Java语言的三大特性是什么？
Java语言的三大特性分别是封装、继承和多态。

- 封装是指将对象的属性私有化，提供一些可以访问属性的方法，我们通过访问这些方法得到对象的属性。

- 继承是指某新类继承已经存在的类，该新类拥有被继承的类的所有属性和方法，并且新类可以根据自己的情况拓展属性或方法。其中新类称为子类，原存在的类被称为父类。
  - 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。
  - 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
  - 子类可以用自己的方式实现父类的方法。
    > 注意：Java不支持多继承

- 多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作。多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。
    > 在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

## Java访问修饰符有哪些？
Java中的访问修饰符有public private protected
- public：对所有类可见。使用对象：类、接口、变量、方法
- private：在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）
- protected：对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。
- default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。

修饰符 | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包) | 其他包
-- | -- | -- | -- | -- | -- |
public | Y | Y | Y | Y | Y 
private| Y | N | N | N | N 
protected | Y | Y | Y | Y | N 
default | Y | Y | Y | N | N 

## Java非访问修饰符有哪些？
Java中的非访问修饰符有static, final, abstract等。

static可以修饰内部类、方法、变量、代码块

- static修饰的类是静态内部类。
- static修饰的方法是静态方法，表示该方法属于当前类的，而不属于某个对象的，静态方法不能使用类的非静态变量，静态方法也不能被重写，可以直接使用类名来调用。在static方法中不能使用this或者super关键字。
- static修饰的变量被称为静态变量，表示该变量属于当前类的，而不属于某个对象的，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为static变量。
- static修饰的代码块叫静态代码块，通常用来做程序优化的。静态代码块中的代码在整个类加载的时候只会执行一次。静态代码块可以有多个，如果有多个，按照先后顺序依次执行。

final可以修饰类，修饰方法，修饰属性。
- 修饰的类叫最终类。该类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。
- 修饰的方法不能被重写，也就是不能被继承类重新定义。
- 当final修饰属性的时候，如果是基本数据类型的变量，则变量变为常量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。

abstract用来创建抽象类和抽象方法。
- 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。抽象类可以包含抽象方法和非抽象方法。
- 抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。抽象方法不能被声明成 final 和 static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。


## 什么是重写？什么是重载？
重载和重写都是java多态的表现。
- 重载叫override。重载是发生在同一个类中，具有相同的方法名，但是有不同的参数，参数的个数不一样、参数的位置不一样，方法的返回值类型可以相同也可以不同，这就叫重载。常见的就比如构造方法，有有参构造和无参构造。
- 重写叫overwrite。当子类继承父类时，对父类中的一些方法根据自己的需求进行重写操作。方法名必须相同，返回值类型必须相同，参数列表必须相同。


## 什么是方法重载？
方法的重载就是在同一个类中允许同时存在一个以上的同名方法，只要它们的参数个数或者类型不同即可。在这种情况下，该方法就叫被重载了，这个过程称为方法的重载（Overloading）

## 什么是方法重写？
方法重写时，子类的返回值必须与父类的一致。当子类出现与父类相同的方法，那么这就是方法重写。如果父类方法抛出一个异常，子类重写的方法抛出的异常类型不能小于父类抛出的异常类型。
## 构造方法能不能重写？能不能重载？
不可以重写，但可以重载。

## 接口和抽象类的相同点和不同点是什么？
接口(interface)和抽象类(abstract class)是支持抽象类定义的两种机制。

接口是公开的，不能有私有的方法或变量，接口中的所有方法都没有方法体，通过关键字interface实现。

抽象类是可以有私有方法或私有变量的，通过把类或者类中的方法声明为abstract来表示一个类是抽象类，被声明为抽象的方法不能包含方法体。子类实现方法必须含有相同的或者更高的访问级别(public->protected->private)。抽象类的子类为父类中所有抽象方法的具体实现，否则也是抽象类。

相同点：
- 都不能被实例化
- 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。

不同点：
- 接口只有定义，不能有方法的实现，但java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。
- 实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
- 接口强调特定功能的实现，而抽象类强调所属关系。
- 接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。
- 接口被用于常用的功能，便于日后维护和添加删除，而抽象类更倾向于充当公共类的角色，不适用于日后重新对立面的代码修改。从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

## 什么是Java中的内部类？
内部类有四种，分别是成员内部类、局部内部类、匿名内部类、静态内部类
- 成员内部类：成员内部类是最普通的内部类，它的定义为位于另一个类的内部，成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。定义如下：
```java
class Circle {
    private double radius = 0;
    public static int count =1;
    public Circle(double radius) {
        this.radius = radius;
    }
     
    class Draw {     //内部类
        public void drawSahpe() {
            System.out.println(radius);  //外部类的private成员
            System.out.println(count);   //外部类的静态成员
        }
    }
}
```
- 局部内部类：局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。定义如下：
```java
class People{
    public People() {
         
    }
}
 
class Man{
    public Man(){
         
    }
     
    public People getWoman(){
        class Woman extends People{   //局部内部类
            int age =0;
        }
        return new Woman();
    }
}
```
- 匿名内部类：是指继承一个父类或者实现一个接口的方式直接定义并使用的类，匿名内部类没有class关键字，因为匿名内部类直接使用new生成一个对象
- 静态内部类：静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。常见的main函数就是静态内部类，调用静态内部类通过“外部类.静态内部类”。定义如下：
```java
public class Test {
    public static void main(String[] args)  {
        Outter.Inner inner = new Outter.Inner();
    }
}
 
class Outter {
    public Outter() {
         
    }
     
    static class Inner {
        public Inner() {
             
        }
    }
}
```



## Java中的异常体系是什么？
Java中的异常主要分为Error和Exception
- Error 指Java程序运行错误，如果程序在启动时出现Error，则启动失败；如果程序运行过程中出现Error，则系统将退出程序。出现Error是系统的内部错误或资源耗尽，Error不能在程序运行过程中被动态处理，一旦出现Error，系统能做的只有记录错误的原因和安全终止。
- Exception 指 Java程序运行异常，在运行中的程序发生了程序员不期望发生的事情，可以被Java异常处理机制处理。Exception也是程序开发中异常处理的核心，可分为RuntimeException（运行时异常）和CheckedException（检查异常）
  - RuntimeException（运行时异常）：指在Java虚拟机正常运行期间抛出的异常，RuntimeException可以被捕获并处理，如果出现此情况，我们需要抛出异常或者捕获并处理异常。常见的有NullPointerException、ClassCastException、ArrayIndexOutOfBoundsException等
  - CheckedException（检查异常）：指在编译阶段Java编译器检查CheckedException异常，并强制程序捕获和处理此类异常，要求程序在可能出现异常的地方通过try catch语句块捕获异常并处理异常。常见的有由于I/O错误导致的IOException、SQLException、ClassNotFoundException等。该类异常通常由于打开错误的文件、SQL语法错误、类不存等引起。

## Java中异常的处理方式有哪些？
异常处理方式有抛出异常和使用try catch语句块捕获异常两种方式。

- 抛出异常：遇到异常时不进行具体的处理，直接将异常抛给调用者，让调用者自己根据情况处理。抛出异常的三种形式：throws、throw和系统自动抛出异常。其中throws作用在方法上，用于定义方法可能抛出的异常；throw作用在方法内，表示明确抛出一个异常。
- 使用try catch捕获并处理异常：使用try catch 捕获异常能够有针对性的处理每种可能出现的异常，并在捕获到异常后根据不同的情况做不同的处理。其使用过程比较简单：用try catch语句块将可能出现异常的代码抱起来即可。

## equals和==的区别是什么？
- \=\=: 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型\=\=比较的是值，引用数据类型==比较的是内存地址)。
- equlas: 
  - 情况 1：类没有重写 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
  - 情况 2：类重写了 equals() 方法。一般，我们都重写 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。



